palletizing_system/
├── config/                # 配置文件目录
│   ├── pallet_config.yaml  # 托盘尺寸、原点偏移量、网格分辨率
│   └── box_config.yaml     # 箱子尺寸（单品规先验数据）
├── data/                  # 离线数据与日志
│   ├── logs/               # 运行日志
│   └── samples/            # 录制的点云数据（用于离线调试算法）
├── src/                   # 源代码核心目录
│   ├── perception/         # 模块1：感知与环境重构
│   │   ├── sensor.py        # 传感器接口（获取图像、点云，处理RGB-D流）
│   │   └── processor.py     # 核心：点云转高度图、降噪、网格化处理
│   ├── planning/           # 模块2：核心算法与逻辑
│   │   ├── pattern.py       # 垛形预设、层级管理逻辑
│   │   └── solver.py        # 核心：在高度图中匹配放置点坐标
│   ├── execution/          # 模块3：执行与运动控制
│   │   ├── arm_interface.py # 机械臂驱动封装
│   │   └── trajectory.py    # 多阶段（Hover-Place）坐标生成
│   ├── visualization/      # 模块4：可视化监控
│   │   ├── viewer_3d.py     # 基于 Open3D 或 Meshlab 的实时点云/高度图显示
│   │   └── dashboard.py     # 基于 OpenCV 的 2D 占用情况监控界面
│   └── utils/              # 通用工具
│       └── math_tools.py    # 坐标系转换、几何运算
├── tests/                 # 单元测试
├── main.py                # 系统总控入口（Orchestrator）
└── requirements.txt       # 依赖清单

📂 各文件夹功能详解1. src/perception/ (传感器获取与处理)这是你的“眼睛”。功能： 负责从 RGB-D 相机获取原始数据。关键任务： 将非结构化的点云（Point Cloud）投影到你想要的二维网格中，生成 Height Map。它要处理“漏检”问题，比如通过帧间融合（Temporal Fusion）来填补深度图的空洞。2. src/planning/ (核心算法)这是你的“大脑”，体现了你说的“根据高度分层”的逻辑。功能： 维护当前的堆垛状态。关键任务： * pattern.py 决定箱子怎么摆（例如第一层横着，第二层竖着）。solver.py 结合高度图，计算“当前层是不是平的”、“预定位置是否有障碍物”。它输出的是最终的物理坐标 $(x, y, z, \theta)$。3. src/visualization/ (可视化看板)这是你的“调试窗口”，对于实时校正非常重要。功能： 将算法感知的“空间占用状态”直观显示出来。关键任务： * 2D 视图： 用颜色深浅表示托盘各区域的高度（Heatmap），一眼看出哪块区域漏放了。3D 视图： 绘制机械臂的目标点位和避障边界，确保多阶段规划符合预期。4. src/execution/ (执行与干涉规避)这是你的“手臂”。功能： 翻译算法指令为机器人的关节运动或笛卡尔运动。关键任务： 实现你提到的多阶段坐标规划。它负责把 planning 给出的一个目标点分解为：安全上方 -> 缓慢下降 -> 放置放气 -> 垂直抬升 四个具体的路点。5. main.py (业务流控制)功能： 串联整个流程。伪代码逻辑：Pythonwhile True:
    img = sensor.get_rgbd()           # 获取传感器图片
    h_map = processor.build(img)      # 核心算法：生成高度图
    target = solver.find_slot(h_map)  # 核心算法：寻找放置位
    visualizer.update(h_map, target)  # 可视化看效果
    motion.execute(target)            # 执行动作

数据回放功能（Data Mocking）： 在 src/perception/sensor.py 中增加一个“离线模式”，可以直接读取 data/samples/ 里的本地文件。这样你不需要机械臂和相机在身边，也能在家里调算法。

配置驱动： 所有的箱子尺寸、托盘高度都写在 config/ 里，千万不要硬编码在算法代码里。这样换一种箱子只需改一下 YAML 文件。

解耦校验： 可以在 src/planning/ 里单独写一个 collision_checker，专门用来验证生成的“多阶段坐标”是否会撞到已经存在于高度图中的物体。
