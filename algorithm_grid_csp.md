# 基于网格离散化与约束满足（CSP）的堆垛算法设计

## 1. 核心理念
传统的“行列式”或“模板式”算法难以处理不规则空间或实现极致的边角利用。本算法引入**空间离散化 (Spatial Discretization)** 技术，将连续的托盘表面划分为有限的**状态网格 (Lattice Grid)**，并将箱子的放置问题转化为在网格上的**约束满足问题 (Constraint Satisfaction Problem, CSP)**。

## 2. 空间表征：XY 网格 (Lattice Grid)
### 2.1 网格定义
*   将托盘平面 $(L \times W)$ 划分为尺寸为 $\delta \times \delta$ 的微元网格。
*   $\delta$ (Grid Size) 取值原则：$\delta \ll \min(Box_L, Box_W)$ 且为箱子尺寸的公约数（如 10mm 或 20mm），以平衡计算精度与效率。
*   **状态矩阵** $G_{M \times N}$：
    *   $G[i, j] = 0$: 空闲 (Free)
    *   $G[i, j] = 1$: 占用 (Occupied)
    *   $G[i, j] = 2$: 禁放区 (Forbidden) - 可用于模拟托盘破损或特殊避让区。

### 2.2 候选状态集合 (State Space)
*   箱子不再受限于预设的“行”或“列”。
*   任何以网格节点 $(x_i, y_j)$ 为左上角（或中心），且满足边界条件的矩形区域，都是一个**潜在的放置候选 (Candidate)**。
*   每个候选 $C$ 由 $(x, y, \theta)$ 定义，其中 $\theta \in \{0^{\circ}, 90^{\circ}\}$。

## 3. 约束满足模型 (CSP Model)
在搜索最优布局时，必须满足以下硬性约束：

### 3.1 几何约束 (Geometric Constraints)
1.  **边界约束 (Boundary)**: 箱子投影必须完全位于托盘网格范围内。
    $$ 0 \le x < M, \quad 0 \le y < N $$
2.  **非重叠约束 (Non-overlapping)**: 候选区域内的所有网格值必须为 0。
    $$ \sum_{(i,j) \in Box\_Region} G[i, j] == 0 $$

### 3.2 物理/业务约束 (Physical & Business Constraints)
1.  **支撑稳定性 (Stability)**: (用于多层规划)
    *   箱子底面投影下的下层网格中，必须有 $\ge \alpha\%$ (如 80%) 的区域具有实体支撑（高度匹配）。
    *   或者：箱子重心的投影点必须位于下层支撑面的凸包内。
2.  **抓取方向 (Gripper Orientation)**:
    *   机械臂末端执行器可能存在旋转限制（例如只能转 $\pm 180^{\circ}$），需过滤不可执行的角度。
3.  **禁放区 (Keep-out Zone)**:
    *   托盘上某些特定区域（如标签面朝向的一侧、把手位置）可能不允许被遮挡。

## 4. 搜索策略：启发式搜索 (Heuristic Search)
由于全网格搜索空间巨大，采用**启发式贪婪算法 (Heuristic Greedy)** 结合 **束搜索 (Beam Search)** 来逼近全局最优。

### 4.1 评价函数 (Score Function)
对每一个合法的候选位置 $C$，计算评分 $S(C)$：
$$ S(C) = w_1 \cdot A_{contact} + w_2 \cdot D_{origin} + w_3 \cdot P_{corner} $$
*   **$A_{contact}$ (邻接度)**: 箱子边缘与已放置箱子或托盘边界的接触长度。鼓励“靠边”和“抱团”，减少碎片空隙。
*   **$D_{origin}$ (紧凑度)**: 距离原点（如左下角）的距离。距离越小分越高，促使从一侧开始填充。
*   **$P_{corner}$ (角点占据)**: 是否占据了当前的“凹角”或“凸角”。优先填充凹角（Hole Filling）。

### 4.2 算法流程
1.  **初始化**: 清空网格 $G$，定义箱子尺寸 $B_L, B_W$。
2.  **生成候选**: 遍历网格所有可用点 $(i, j)$，检查两种旋转状态 $(0^{\circ}, 90^{\circ})$ 的合法性（边界、重叠、禁放）。
3.  **评分与排序**: 计算所有合法候选的 $S(C)$，按分数降序排列。
4.  **贪婪选择**:
    *   选择分数最高的候选 $C_{best}$。
    *   **更新网格**: 将 $C_{best}$ 覆盖的区域标记为 1。
    *   记录动作。
5.  **迭代**: 重复步骤 2-4，直到没有合法候选为止。
6.  **输出**: 返回所有放置动作序列。

## 5. 优势
*   **灵活性**: 天然支持不同尺寸混装（虽本次任务单一尺寸，但架构通用）。
*   **空间利用率**: 能够自动发现并利用“行列式”算法忽略的边角空间（例如利用旋转 90 度来填补剩余长条区域）。
*   **可扩展性**: 新增约束只需在 `is_valid()` 函数中增加判断逻辑即可。
